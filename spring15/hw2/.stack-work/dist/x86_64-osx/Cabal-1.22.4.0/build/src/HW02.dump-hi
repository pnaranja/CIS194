
==================== FINAL INTERFACE ====================
2015-12-28 17:43:39.972033 UTC

interface hw2_A5y52is64x8Angxr5cQPyn:HW02 7102
  interface hash: c55515320e04194249dd2c8f353157e1
  ABI hash: 969cb8237e7865220b81a3a180d0eb50
  export-list hash: 527c1f23de9cdc5c059d22c5517d3def
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 56b9a755d22be00f2eba50f3628a69c7
  sig of: Nothing
  used TH splices: False
  where
exports:
  HW02.activeTuples
  HW02.addColors
  HW02.allCodes
  HW02.colors
  HW02.countColor
  HW02.countColors
  HW02.exactMatches
  HW02.extractCodeFromMove
  HW02.extractMatchesFromMove
  HW02.filterCodes
  HW02.fiveGuess
  HW02.getMatch
  HW02.getMove
  HW02.getTuples
  HW02.isConsistent
  HW02.matches
  HW02.solve
  HW02.solver
  HW02.Code
  HW02.Move{HW02.Move}
  HW02.Peg{HW02.Blue HW02.Green HW02.Orange HW02.Purple HW02.Red HW02.Yellow}
module dependencies:
package dependencies: base-4.8.1.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Monoid
                         base-4.8.1.0:Data.Type.Equality base-4.8.1.0:GHC.Generics
import  -/  base-4.8.1.0:Data.Foldable 2e5acb797cfda6b3b7fabd7052abe290
import  -/  base-4.8.1.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.1.0:GHC.List f31ed8784b3e05f1397195751f7d74ea
import  -/  base-4.8.1.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.1.0:GHC.Show b8c65ca3124f92a166c9f05120382442
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
c85f3c558f4d94f7f7850752ea3f2c60
  $fEqMove :: GHC.Classes.Eq HW02.Move
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ HW02.Move HW02.$fEqMove_$c== HW02.$fEqMove_$c/= -}
c85f3c558f4d94f7f7850752ea3f2c60
  $fEqMove_$c/= :: HW02.Move -> HW02.Move -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U(U),1*U(U))><S(SLL),1*U(1*U,1*U(U),1*U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: HW02.Move b :: HW02.Move ->
                 case HW02.$fEqMove_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
c85f3c558f4d94f7f7850752ea3f2c60
  $fEqMove_$c== :: HW02.Move -> HW02.Move -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U(U),1*U(U))><S(SLL),1*U(1*U,1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: HW02.Move w1 :: HW02.Move ->
                 case w of ww { HW02.Move ww1 ww2 ww3 ->
                 case w1 of ww4 { HW02.Move ww5 ww6 ww7 ->
                 HW02.$w$c== ww1 ww2 ww3 ww5 ww6 ww7 } }) -}
fab6d2287c980e7f46cbd4327c7fdbd4
  $fEqPeg :: GHC.Classes.Eq HW02.Peg
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:. @ HW02.Peg HW02.$fEqPeg_$c== HW02.$fEqPeg_$c/= -}
fab6d2287c980e7f46cbd4327c7fdbd4
  $fEqPeg_$c/= :: HW02.Peg -> HW02.Peg -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: HW02.Peg b :: HW02.Peg ->
                 case a of wild {
                   HW02.Red
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True HW02.Red -> GHC.Types.False }
                   HW02.Green
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True HW02.Green -> GHC.Types.False }
                   HW02.Blue
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True HW02.Blue -> GHC.Types.False }
                   HW02.Yellow
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True HW02.Yellow -> GHC.Types.False }
                   HW02.Orange
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True HW02.Orange -> GHC.Types.False }
                   HW02.Purple
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True HW02.Purple -> GHC.Types.False } }) -}
fab6d2287c980e7f46cbd4327c7fdbd4
  $fEqPeg_$c== :: HW02.Peg -> HW02.Peg -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: HW02.Peg ds1 :: HW02.Peg ->
                 case ds of wild {
                   HW02.Red
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False HW02.Red -> GHC.Types.True }
                   HW02.Green
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False HW02.Green -> GHC.Types.True }
                   HW02.Blue
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False HW02.Blue -> GHC.Types.True }
                   HW02.Yellow
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False HW02.Yellow -> GHC.Types.True }
                   HW02.Orange
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False HW02.Orange -> GHC.Types.True }
                   HW02.Purple
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False HW02.Purple -> GHC.Types.True } }) -}
fab6d2287c980e7f46cbd4327c7fdbd4
  $fOrdPeg :: GHC.Classes.Ord HW02.Peg
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ HW02.Peg
                  HW02.$fEqPeg
                  HW02.$fOrdPeg_$ccompare
                  HW02.$fOrdPeg_$c<
                  HW02.$fOrdPeg_$c<=
                  HW02.$fOrdPeg_$c>
                  HW02.$fOrdPeg_$c>=
                  HW02.$fOrdPeg_$cmax
                  HW02.$fOrdPeg_$cmin -}
fab6d2287c980e7f46cbd4327c7fdbd4
  $fOrdPeg_$c< :: HW02.Peg -> HW02.Peg -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: HW02.Peg b :: HW02.Peg ->
                 case a of wild {
                   HW02.Red
                   -> case b of wild1 {
                        HW02.Red -> GHC.Types.False
                        HW02.Green -> GHC.Types.True
                        HW02.Blue -> GHC.Types.True
                        HW02.Yellow -> GHC.Types.True
                        HW02.Orange -> GHC.Types.True
                        HW02.Purple -> GHC.Types.True }
                   HW02.Green
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        HW02.Blue -> GHC.Types.True
                        HW02.Yellow -> GHC.Types.True
                        HW02.Orange -> GHC.Types.True
                        HW02.Purple -> GHC.Types.True }
                   HW02.Blue
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        HW02.Yellow -> GHC.Types.True
                        HW02.Orange -> GHC.Types.True
                        HW02.Purple -> GHC.Types.True }
                   HW02.Yellow
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        HW02.Orange -> GHC.Types.True
                        HW02.Purple -> GHC.Types.True }
                   HW02.Orange
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False HW02.Purple -> GHC.Types.True }
                   HW02.Purple -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
fab6d2287c980e7f46cbd4327c7fdbd4
  $fOrdPeg_$c<= :: HW02.Peg -> HW02.Peg -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: HW02.Peg b :: HW02.Peg ->
                 case a of wild {
                   HW02.Red -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   HW02.Green
                   -> case b of wild1 {
                        HW02.Red -> GHC.Types.False
                        HW02.Green -> GHC.Types.True
                        HW02.Blue -> GHC.Types.True
                        HW02.Yellow -> GHC.Types.True
                        HW02.Orange -> GHC.Types.True
                        HW02.Purple -> GHC.Types.True }
                   HW02.Blue
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        HW02.Blue -> GHC.Types.True
                        HW02.Yellow -> GHC.Types.True
                        HW02.Orange -> GHC.Types.True
                        HW02.Purple -> GHC.Types.True }
                   HW02.Yellow
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        HW02.Yellow -> GHC.Types.True
                        HW02.Orange -> GHC.Types.True
                        HW02.Purple -> GHC.Types.True }
                   HW02.Orange
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        HW02.Orange -> GHC.Types.True
                        HW02.Purple -> GHC.Types.True }
                   HW02.Purple
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False HW02.Purple -> GHC.Types.True } }) -}
fab6d2287c980e7f46cbd4327c7fdbd4
  $fOrdPeg_$c> :: HW02.Peg -> HW02.Peg -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: HW02.Peg b :: HW02.Peg ->
                 case a of wild {
                   HW02.Red -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   HW02.Green
                   -> case b of wild1 {
                        HW02.Red -> GHC.Types.True
                        HW02.Green -> GHC.Types.False
                        HW02.Blue -> GHC.Types.False
                        HW02.Yellow -> GHC.Types.False
                        HW02.Orange -> GHC.Types.False
                        HW02.Purple -> GHC.Types.False }
                   HW02.Blue
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        HW02.Blue -> GHC.Types.False
                        HW02.Yellow -> GHC.Types.False
                        HW02.Orange -> GHC.Types.False
                        HW02.Purple -> GHC.Types.False }
                   HW02.Yellow
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        HW02.Yellow -> GHC.Types.False
                        HW02.Orange -> GHC.Types.False
                        HW02.Purple -> GHC.Types.False }
                   HW02.Orange
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        HW02.Orange -> GHC.Types.False
                        HW02.Purple -> GHC.Types.False }
                   HW02.Purple
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True HW02.Purple -> GHC.Types.False } }) -}
fab6d2287c980e7f46cbd4327c7fdbd4
  $fOrdPeg_$c>= :: HW02.Peg -> HW02.Peg -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: HW02.Peg b :: HW02.Peg ->
                 case a of wild {
                   HW02.Red
                   -> case b of wild1 {
                        HW02.Red -> GHC.Types.True
                        HW02.Green -> GHC.Types.False
                        HW02.Blue -> GHC.Types.False
                        HW02.Yellow -> GHC.Types.False
                        HW02.Orange -> GHC.Types.False
                        HW02.Purple -> GHC.Types.False }
                   HW02.Green
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        HW02.Blue -> GHC.Types.False
                        HW02.Yellow -> GHC.Types.False
                        HW02.Orange -> GHC.Types.False
                        HW02.Purple -> GHC.Types.False }
                   HW02.Blue
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        HW02.Yellow -> GHC.Types.False
                        HW02.Orange -> GHC.Types.False
                        HW02.Purple -> GHC.Types.False }
                   HW02.Yellow
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        HW02.Orange -> GHC.Types.False
                        HW02.Purple -> GHC.Types.False }
                   HW02.Orange
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True HW02.Purple -> GHC.Types.False }
                   HW02.Purple -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
fab6d2287c980e7f46cbd4327c7fdbd4
  $fOrdPeg_$ccompare :: HW02.Peg -> HW02.Peg -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: HW02.Peg b :: HW02.Peg ->
                 case a of wild {
                   HW02.Red
                   -> case b of wild1 {
                        HW02.Red -> GHC.Types.EQ
                        HW02.Green -> GHC.Types.LT
                        HW02.Blue -> GHC.Types.LT
                        HW02.Yellow -> GHC.Types.LT
                        HW02.Orange -> GHC.Types.LT
                        HW02.Purple -> GHC.Types.LT }
                   HW02.Green
                   -> case b of wild1 {
                        HW02.Red -> GHC.Types.GT
                        HW02.Green -> GHC.Types.EQ
                        HW02.Blue -> GHC.Types.LT
                        HW02.Yellow -> GHC.Types.LT
                        HW02.Orange -> GHC.Types.LT
                        HW02.Purple -> GHC.Types.LT }
                   HW02.Blue
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        HW02.Blue -> GHC.Types.EQ
                        HW02.Yellow -> GHC.Types.LT
                        HW02.Orange -> GHC.Types.LT
                        HW02.Purple -> GHC.Types.LT }
                   HW02.Yellow
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        HW02.Yellow -> GHC.Types.EQ
                        HW02.Orange -> GHC.Types.LT
                        HW02.Purple -> GHC.Types.LT }
                   HW02.Orange
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        HW02.Orange -> GHC.Types.EQ
                        HW02.Purple -> GHC.Types.LT }
                   HW02.Purple
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT HW02.Purple -> GHC.Types.EQ } }) -}
fab6d2287c980e7f46cbd4327c7fdbd4
  $fOrdPeg_$cmax :: HW02.Peg -> HW02.Peg -> HW02.Peg
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: HW02.Peg y :: HW02.Peg ->
                 case x of wild {
                   HW02.Red -> y
                   HW02.Green
                   -> case y of wild1 {
                        DEFAULT -> HW02.Green
                        HW02.Blue -> HW02.Blue
                        HW02.Yellow -> HW02.Yellow
                        HW02.Orange -> HW02.Orange
                        HW02.Purple -> HW02.Purple }
                   HW02.Blue
                   -> case y of wild1 {
                        DEFAULT -> HW02.Blue
                        HW02.Yellow -> HW02.Yellow
                        HW02.Orange -> HW02.Orange
                        HW02.Purple -> HW02.Purple }
                   HW02.Yellow
                   -> case y of wild1 {
                        DEFAULT -> HW02.Yellow
                        HW02.Orange -> HW02.Orange
                        HW02.Purple -> HW02.Purple }
                   HW02.Orange
                   -> case y of wild1 {
                        DEFAULT -> HW02.Orange HW02.Purple -> HW02.Purple }
                   HW02.Purple -> case y of wild1 { DEFAULT -> HW02.Purple } }) -}
fab6d2287c980e7f46cbd4327c7fdbd4
  $fOrdPeg_$cmin :: HW02.Peg -> HW02.Peg -> HW02.Peg
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: HW02.Peg y :: HW02.Peg ->
                 case x of wild {
                   HW02.Red -> case y of wild1 { DEFAULT -> HW02.Red }
                   HW02.Green
                   -> case y of wild1 {
                        HW02.Red -> HW02.Red
                        HW02.Green -> HW02.Green
                        HW02.Blue -> HW02.Green
                        HW02.Yellow -> HW02.Green
                        HW02.Orange -> HW02.Green
                        HW02.Purple -> HW02.Green }
                   HW02.Blue
                   -> case y of wild1 {
                        DEFAULT -> wild1
                        HW02.Blue -> HW02.Blue
                        HW02.Yellow -> HW02.Blue
                        HW02.Orange -> HW02.Blue
                        HW02.Purple -> HW02.Blue }
                   HW02.Yellow
                   -> case y of wild1 {
                        DEFAULT -> wild1
                        HW02.Yellow -> HW02.Yellow
                        HW02.Orange -> HW02.Yellow
                        HW02.Purple -> HW02.Yellow }
                   HW02.Orange
                   -> case y of wild1 {
                        DEFAULT -> wild1
                        HW02.Orange -> HW02.Orange
                        HW02.Purple -> HW02.Orange }
                   HW02.Purple -> y }) -}
c85f3c558f4d94f7f7850752ea3f2c60
  $fShowMove :: GHC.Show.Show HW02.Move
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ HW02.Move
                  HW02.$fShowMove_$cshowsPrec
                  HW02.$fShowMove_$cshow
                  HW02.$fShowMove_$cshowList -}
c85f3c558f4d94f7f7850752ea3f2c60
  $fShowMove1 :: HW02.Move -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: HW02.Move w1 :: GHC.Base.String ->
                 case w of ww { HW02.Move ww1 ww2 ww3 ->
                 HW02.$w$cshowsPrec 0 ww1 ww2 ww3 w1 }) -}
54343593457308af48c2eef4e48dc2e9
  $fShowMove2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Purple"#) -}
8735b534cfe84b003974a1b2456b1d83
  $fShowMove3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Orange"#) -}
b00d2d6b9cd8bf8ae3e8fdbf4601dc2e
  $fShowMove4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Yellow"#) -}
798053f402dd037aa45d966f44cd37c3
  $fShowMove5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Blue"#) -}
6fec1b88bd88d46700be1abebf28681e
  $fShowMove6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Green"#) -}
b63195c1d555f790f8aecb8fab655b91
  $fShowMove7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Red"#) -}
84f4f294aea3daebf7a0d6a48c54f4bf
  $fShowMove8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Move "#) -}
c85f3c558f4d94f7f7850752ea3f2c60
  $fShowMove_$cshow :: HW02.Move -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U(U),1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: HW02.Move ->
                 HW02.$fShowMove_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
c85f3c558f4d94f7f7850752ea3f2c60
  $fShowMove_$cshowList :: [HW02.Move] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ HW02.Move HW02.$fShowMove1) -}
c85f3c558f4d94f7f7850752ea3f2c60
  $fShowMove_$cshowsPrec ::
    GHC.Types.Int -> HW02.Move -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U,1*U(U),1*U(U))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: HW02.Move w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { HW02.Move ww3 ww4 ww5 ->
                 HW02.$w$cshowsPrec ww1 ww3 ww4 ww5 w2 } }) -}
fab6d2287c980e7f46cbd4327c7fdbd4
  $fShowPeg :: GHC.Show.Show HW02.Peg
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ HW02.Peg
                  HW02.$fShowPeg_$cshowsPrec
                  HW02.$fShowPeg_$cshow
                  HW02.$fShowPeg_$cshowList -}
fab6d2287c980e7f46cbd4327c7fdbd4
  $fShowPeg_$cshow :: HW02.Peg -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: HW02.Peg ->
                 HW02.$fShowPeg_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
fab6d2287c980e7f46cbd4327c7fdbd4
  $fShowPeg_$cshowList :: [HW02.Peg] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ HW02.Peg HW02.$w$cshowsPrec1) -}
fab6d2287c980e7f46cbd4327c7fdbd4
  $fShowPeg_$cshowsPrec ::
    GHC.Types.Int -> HW02.Peg -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int w1 :: HW02.Peg w2 :: GHC.Base.String ->
                 HW02.$w$cshowsPrec1 w1 w2) -}
55d6a44fdea908a957a3d07d0a747cc1
  $w$c== ::
    HW02.Code
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> HW02.Code
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(U)><L,1*U(U)><S,1*U><L,1*U(U)><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ ww :: HW02.Code
                   ww1 :: GHC.Types.Int
                   ww2 :: GHC.Types.Int
                   ww3 :: HW02.Code
                   ww4 :: GHC.Types.Int
                   ww5 :: GHC.Types.Int ->
                 case GHC.Classes.$fEq[]_$c==
                        @ HW02.Peg
                        HW02.$fEqPeg
                        ww
                        ww3 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Types.I# x ->
                      case ww4 of wild2 { GHC.Types.I# y ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x y) of wild3 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True -> GHC.Classes.eqInt ww2 ww5 } } } }) -}
563e50fb45c3c024c8cbe3648fa5887b
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> HW02.Code
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 5, Strictness: <L,U><L,1*U><L,1*U(U)><L,1*U(U)><L,U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: HW02.Code
                   ww2 :: GHC.Types.Int
                   ww3 :: GHC.Types.Int
                   w :: GHC.Base.String ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       HW02.$fShowMove8
                       (GHC.Show.showList__
                          @ HW02.Peg
                          HW02.$w$cshowsPrec1
                          ww1
                          (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.showSpace1
                             (case ww2 of ww4 { GHC.Types.I# ww5 ->
                              case GHC.Show.$wshowSignedInt
                                     11
                                     ww5
                                     (GHC.Types.:
                                        @ GHC.Types.Char
                                        GHC.Show.showSpace1
                                        (case ww3 of ww6 { GHC.Types.I# ww7 ->
                                         case GHC.Show.$wshowSignedInt
                                                11
                                                ww7
                                                x of ww8 { (#,#) ww9 ww10 ->
                                         GHC.Types.:
                                           @ GHC.Types.Char
                                           ww9
                                           ww10 } })) of ww6 { (#,#) ww7 ww8 ->
                              GHC.Types.: @ GHC.Types.Char ww7 ww8 } })))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p w
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w)) }) -}
fab6d2287c980e7f46cbd4327c7fdbd4
  $w$cshowsPrec1 :: HW02.Peg -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: HW02.Peg w1 :: GHC.Base.String ->
                 case w of wild {
                   HW02.Red -> GHC.Base.++ @ GHC.Types.Char HW02.$fShowMove7 w1
                   HW02.Green -> GHC.Base.++ @ GHC.Types.Char HW02.$fShowMove6 w1
                   HW02.Blue -> GHC.Base.++ @ GHC.Types.Char HW02.$fShowMove5 w1
                   HW02.Yellow -> GHC.Base.++ @ GHC.Types.Char HW02.$fShowMove4 w1
                   HW02.Orange -> GHC.Base.++ @ GHC.Types.Char HW02.$fShowMove3 w1
                   HW02.Purple
                   -> GHC.Base.++ @ GHC.Types.Char HW02.$fShowMove2 w1 }) -}
c3b42eaa6e02fa7b5822d4f06b561ef5
  $wallCodes :: GHC.Prim.Int# -> [HW02.Code]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
664fef39c7172b692b1ee944a2aaf5bd
  $wcountColor :: HW02.Peg -> HW02.Code -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>, Inline: [0],
     Unfolding: (\ w :: HW02.Peg w1 :: HW02.Code ->
                 letrec {
                   $wgo1 :: [HW02.Peg] -> GHC.Prim.Int# -> GHC.Prim.Int#
                     {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
                   = \ w2 :: [HW02.Peg] ww :: GHC.Prim.Int# ->
                     case w2 of wild {
                       [] -> ww
                       : y ys
                       -> case y of wild1 {
                            HW02.Red
                            -> case w of wild2 {
                                 DEFAULT -> $wgo1 ys ww HW02.Red -> $wgo1 ys (GHC.Prim.+# ww 1) }
                            HW02.Green
                            -> case w of wild2 {
                                 DEFAULT -> $wgo1 ys ww HW02.Green -> $wgo1 ys (GHC.Prim.+# ww 1) }
                            HW02.Blue
                            -> case w of wild2 {
                                 DEFAULT -> $wgo1 ys ww HW02.Blue -> $wgo1 ys (GHC.Prim.+# ww 1) }
                            HW02.Yellow
                            -> case w of wild2 {
                                 DEFAULT -> $wgo1 ys ww HW02.Yellow -> $wgo1 ys (GHC.Prim.+# ww 1) }
                            HW02.Orange
                            -> case w of wild2 {
                                 DEFAULT -> $wgo1 ys ww HW02.Orange -> $wgo1 ys (GHC.Prim.+# ww 1) }
                            HW02.Purple
                            -> case w of wild2 {
                                 DEFAULT -> $wgo1 ys ww
                                 HW02.Purple -> $wgo1 ys (GHC.Prim.+# ww 1) } } }
                 } in
                 $wgo1 w1 0) -}
d9e184e66ee5e75ef038df10c157cc8b
  $wexactMatches :: HW02.Code -> HW02.Code -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>, Inline: [0] -}
16b513ae169b67f1586f5a7faace5113
  $wgo :: [GHC.Types.Int] -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
4de3ec033a3c076d16c932ee586d05ec
  $wisConsistent ::
    HW02.Code
    -> GHC.Prim.Int# -> GHC.Types.Int -> HW02.Code -> GHC.Types.Bool
  {- Arity: 4, Strictness: <S,U><L,U><L,1*U(U)><S,U>, Inline: [0],
     Unfolding: (\ ww :: HW02.Code
                   ww1 :: GHC.Prim.Int#
                   ww2 :: GHC.Types.Int
                   w :: HW02.Code ->
                 case HW02.$wexactMatches ww w of ww3 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww1 ww3) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww2 of wild1 { GHC.Types.I# x ->
                      case HW02.$wmatches ww w of ww4 { DEFAULT ->
                      GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# x (GHC.Prim.-# ww4 ww3)) } } } }) -}
7bbd542b3901dbd34407d1324bc4f1fe
  $wmatches :: HW02.Code -> HW02.Code -> GHC.Prim.Int#
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: HW02.Code w1 :: HW02.Code ->
                 case HW02.isConsistent_go
                        (HW02.countColors w)
                        (HW02.countColors w1) of wild {
                   [] -> case GHC.List.foldl2 ret_ty GHC.Prim.Int# of {}
                   : x xs
                   -> case x of ww { GHC.Types.I# ww1 -> HW02.$wgo xs ww1 } }) -}
32a2fbdc877e5764f544f519e3aa4c5e
  $wsolver ::
    HW02.Code
    -> HW02.Code -> [HW02.Code] -> (# HW02.Move, [HW02.Move] #)
  {- Arity: 3, Strictness: <S,U><S,U><L,1*U>, Inline: [0] -}
c5cad7021554684a3c906a9a460d02bb
  type Code = [HW02.Peg]
c85f3c558f4d94f7f7850752ea3f2c60
  data Move = Move HW02.Code GHC.Types.Int GHC.Types.Int
fab6d2287c980e7f46cbd4327c7fdbd4
  data Peg = Red | Green | Blue | Yellow | Orange | Purple
    Promotable
1a7797ba82be273ea0f86063472292cc
  activeTuples ::
    [(GHC.Types.Int, GHC.Types.Int)]
    -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (GHC.List.filter
                   @ (GHC.Types.Int, GHC.Types.Int)
                   HW02.activeTuples1) -}
a45bd00ec8c71bf62a00e263ff932cd3
  activeTuples1 :: (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U),1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: (GHC.Types.Int, GHC.Types.Int) ->
                 case ds of wild { (,) x y ->
                 case x of wild1 { GHC.Types.I# x1 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x1 0) of wild2 {
                   GHC.Types.False
                   -> case y of wild3 { GHC.Types.I# x2 ->
                      GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># x2 0) }
                   GHC.Types.True -> GHC.Types.True } } }) -}
a9c269ee491f38a37b1b07d33c47028d
  addColors :: [HW02.Code] -> [HW02.Code]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ lst :: [HW02.Code] -> HW02.addColors_go lst) -}
4ef1c8f00192d336e0b31561e0cc83e5
  addColors_go :: [[HW02.Peg]] -> [HW02.Code]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
587427be869fb221249aa13f7c761bc8
  allCodes :: GHC.Types.Int -> [HW02.Code]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 -> HW02.$wallCodes ww1 }) -}
d50da314a0f7e7dccfa9dcdacc48b402
  colors :: [HW02.Peg]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.: @ HW02.Peg HW02.Red HW02.colors1) -}
70ecf60c7f08cbb5f3352155554a0781
  colors1 :: [HW02.Peg]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.: @ HW02.Peg HW02.Green HW02.colors2) -}
a1ceb4fbb728da84889876d75affde2f
  colors2 :: [HW02.Peg]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.: @ HW02.Peg HW02.Blue HW02.colors3) -}
9da902aec490b6c1238235cea306feef
  colors3 :: [HW02.Peg]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.: @ HW02.Peg HW02.Yellow HW02.colors4) -}
3eb415449496ae8e4cfccf2cfdc73a98
  colors4 :: [HW02.Peg]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.: @ HW02.Peg HW02.Orange HW02.colors5) -}
a408a8951cbe03e261d92f433489a593
  colors5 :: [HW02.Peg]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ HW02.Peg
                   HW02.Purple
                   (GHC.Types.[] @ HW02.Peg)) -}
7ca5556b9df62b795f73bcccea7eb2e9
  countColor :: HW02.Peg -> HW02.Code -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: HW02.Peg w1 :: HW02.Code ->
                 case HW02.$wcountColor w w1 of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
e93394c373cfed7ab9a7e739f6d64701
  countColors :: HW02.Code -> [GHC.Types.Int]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ ds :: [HW02.Peg] ->
                 case ds of wild {
                   [] -> HW02.countColors1
                   : ipv ipv1
                   -> GHC.Base.map
                        @ HW02.Peg
                        @ GHC.Types.Int
                        (\ peg :: HW02.Peg ->
                         case HW02.$wcountColor peg wild of ww { DEFAULT ->
                         GHC.Types.I# ww })
                        HW02.colors }) -}
55ea7aaf05e8336917f117fccd29c39e
  countColors1 :: [GHC.Types.Int]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Int
                   HW02.countColors7
                   HW02.countColors2) -}
9acc131286b1bd270de383dc3b523a67
  countColors2 :: [GHC.Types.Int]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Int
                   HW02.countColors7
                   HW02.countColors3) -}
21b8aeed08752984d43237482f035ce3
  countColors3 :: [GHC.Types.Int]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Int
                   HW02.countColors7
                   HW02.countColors4) -}
ed5af27e763f5fb7cf14575375d63bdf
  countColors4 :: [GHC.Types.Int]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Int
                   HW02.countColors7
                   HW02.countColors5) -}
b4e9e86ed54bd92be1c825d9fade0ff2
  countColors5 :: [GHC.Types.Int]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Int
                   HW02.countColors7
                   HW02.countColors6) -}
1e528d1f442b900b4af20b7826b7b778
  countColors6 :: [GHC.Types.Int]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Int
                   HW02.countColors7
                   (GHC.Types.[] @ GHC.Types.Int)) -}
9bfaad94f8d90e7deb36039cf866d72d
  countColors7 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
93f5817da9cd42e8e0c9a191b4079e20
  exactMatches :: HW02.Code -> HW02.Code -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: HW02.Code w1 :: HW02.Code ->
                 case HW02.$wexactMatches w w1 of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
6e3e0ab27f5b5e61e57acec32d0ba9c4
  extractCodeFromMove :: HW02.Move -> HW02.Code
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: HW02.Move ->
                 case ds of wild { HW02.Move x ds1 ds2 -> x }) -}
e6f51d8e9eef837f85b3ee88b88be05a
  extractMatchesFromMove ::
    HW02.Move -> (GHC.Types.Int, GHC.Types.Int)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(A,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: HW02.Move ->
                 case ds of wild { HW02.Move ds1 i1 i2 -> (i1, i2) }) -}
335274f629a509b154b0b26704b9c8a9
  filterCodes :: HW02.Move -> [HW02.Code] -> [HW02.Code]
  {- Arity: 2, Strictness: <L,U(U,U(U),U(U))><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ mv :: HW02.Move cd :: [HW02.Code] ->
                 GHC.Base.build
                   @ [HW02.Peg]
                   (\ @ b c :: [HW02.Peg] -> b -> b[OneShot] n :: b[OneShot] ->
                    GHC.Base.foldr
                      @ [HW02.Peg]
                      @ b
                      (GHC.List.filterFB
                         @ [HW02.Peg]
                         @ b
                         c
                         (\ c1 :: HW02.Code -> HW02.isConsistent mv c1))
                      n
                      cd)) -}
7a2ee6462314112fc5a76c69e3037331
  fiveGuess :: HW02.Code -> [HW02.Move]
  {- Strictness: b,
     Unfolding: InlineRule (0, True, True)
                (GHC.Err.undefined @ (HW02.Code -> [HW02.Move])) -}
7c3f66c54a9e3008428e2c71d0812808
  getMatch :: (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SS),1*U(1*U(U),1*U(U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: (GHC.Types.Int, GHC.Types.Int) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww4 ww6) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<# ww4 ww6) of wild1 {
                        GHC.Types.False
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.># ww4 ww6) of wild2 {
                             GHC.Types.False -> GHC.Types.I# 0
                             GHC.Types.True -> GHC.Types.I# ww6 }
                        GHC.Types.True -> GHC.Types.I# ww4 }
                   GHC.Types.True -> GHC.Types.I# ww4 } } } }) -}
8bc77b924a3f57b99ec257b8e2b994b3
  getMove :: HW02.Code -> HW02.Code -> HW02.Move
  {- Arity: 2, Strictness: <L,U><L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: HW02.Code w1 :: HW02.Code ->
                 let {
                   m1 :: GHC.Types.Int
                   = case HW02.$wexactMatches w w1 of ww { DEFAULT ->
                     GHC.Types.I# ww }
                 } in
                 HW02.Move
                   w1
                   m1
                   (case HW02.$wmatches w w1 of ww { DEFAULT ->
                    case m1 of wild1 { GHC.Types.I# y ->
                    GHC.Types.I# (GHC.Prim.-# ww y) } })) -}
1c142a353332dbd7b650c3f6e66d868f
  getTuples ::
    HW02.Code -> HW02.Code -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ c1 :: HW02.Code c2 :: HW02.Code ->
                 GHC.Base.build
                   @ (GHC.Types.Int, GHC.Types.Int)
                   (\ @ b1
                      c :: (GHC.Types.Int, GHC.Types.Int) -> b1 -> b1[OneShot]
                      n :: b1[OneShot] ->
                    GHC.List.foldr2
                      @ GHC.Types.Int
                      @ GHC.Types.Int
                      @ b1
                      (GHC.List.zipFB @ GHC.Types.Int @ GHC.Types.Int @ b1 @ b1 c)
                      n
                      (HW02.countColors c1)
                      (HW02.countColors c2))) -}
1769d63c6226b2c807b2af84cd620d5e
  isConsistent :: HW02.Move -> HW02.Code -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S(SSL),1*U(U,1*U(U),1*U(U))><S,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: HW02.Move w1 :: HW02.Code ->
                 case w of ww { HW02.Move ww1 ww2 ww3 ->
                 case ww2 of ww4 { GHC.Types.I# ww5 ->
                 HW02.$wisConsistent ww1 ww5 ww3 w1 } }) -}
04ba59c1255ce91336833e1aebf277fe
  isConsistent_go ::
    [GHC.Types.Int] -> [GHC.Types.Int] -> [GHC.Types.Int]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
89009934ae5cdfb09b3cb4f856230f0a
  matches :: HW02.Code -> HW02.Code -> GHC.Types.Int
  {- Arity: 2, Strictness: <S,1*U><L,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: HW02.Code w1 :: HW02.Code ->
                 case HW02.$wmatches w w1 of ww { DEFAULT -> GHC.Types.I# ww }) -}
8964f740312ae947469564f3fd3062f0
  solve :: HW02.Code -> [HW02.Move]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: [HW02.Peg] ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ HW02.Move
                   : ipv ipv1
                   -> HW02.solver wild HW02.solve1 HW02.solve_allCodeStart }) -}
d81778817a065354c1c659567d528c5e
  solve1 :: HW02.Code
  {- Unfolding: (case HW02.solve_allCodeStart of wild {
                   [] -> GHC.List.badHead @ HW02.Code : x ds1 -> x }) -}
27e89f417295026f2aa7d4f71edb5ce3
  solve_allCodeStart :: [HW02.Code]
  {- Unfolding: (HW02.$wallCodes 4) -}
7c2b00ee4d983987c99df7d8034daa59
  solver :: HW02.Code -> HW02.Code -> [HW02.Code] -> [HW02.Move]
  {- Arity: 3, Strictness: <S,U><S,U><L,1*U>m2, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: HW02.Code w1 :: HW02.Code w2 :: [HW02.Code] ->
                 case HW02.$wsolver w w1 w2 of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ HW02.Move ww1 ww2 }) -}
instance GHC.Classes.Eq [HW02.Move] = HW02.$fEqMove
instance GHC.Classes.Eq [HW02.Peg] = HW02.$fEqPeg
instance GHC.Classes.Ord [HW02.Peg] = HW02.$fOrdPeg
instance GHC.Show.Show [HW02.Move] = HW02.$fShowMove
instance GHC.Show.Show [HW02.Peg] = HW02.$fShowPeg
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

